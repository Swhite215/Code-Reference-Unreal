Title: Unreeal Engine 4 Game Development in 24 Hours
Authors: Aram Cookson, Ryan DowlingSoka, and Clinton Crumpler

Summarization of Content

Chapter 1 - Introducing Unreal Engine 4
    a. Installing Unreal
        - Epice Games Launcher -> Library -> Add Version -> Selet Version -> Install
    b. Creating Your First Project
        - Project Browser -> Blueprint/C++ -> Template -> Target Hardware -> Graphics Quality -> With Starter Content -> Location -> Name -> Create Project
    c. Learning the Interface
        - Layout Interface is Modifiable
        - Menu Bar - File, Edit, Window, and Help
        - Modes Panel
            - Place Mode - For placing actors in a scene
            - Paint Mode - For painting vertex color data on Static Mesh Actors
            - Landscape Mode - For Editing Landscape Terrain Actors
            - Foliage Mode - For painting instanced Foliage Actors in a Level
            - Geometry Editing Mode - For Editing BSP Brush Actors on the vertex edge face level
        - World Outlinier Panel - Displays all the actors within the current level in a hierarchical view
        - Detail Panel - displays all the editable properties for the selected actor in the Viewport
        - Content Browser Panel - primary area for managing assets in a project
        - Viewport Panel - windows into the world you create. Use to move around the current level
            - Viewport Types - Perspective and Orthographic
    d. View Modes and Visualizers
        - Lit - Shows the final result of a scene with materials and lighting applied
        - Unlit - Removes all lighting from the scene, showing base color from assigned materials
        - Wireframe - Shows all the polygon edges of Actors in the scene
        - Detail Lighting - Displays a neautral material across the entire scene, using the normal maps of the assigned materials
        - Lighting Only - Displays neutral materials that is affected only by lighting without normal maps data
    e. Playing a Level

Chapter 2 - Understanding the Gameplay Framework
    a. Available Resources
        - Epic Games Launcher Community and Learn Sections
        - Play-In Editor - collection of options that allowqs you to playtest a level without having to compile or package content beforehand
        - Project Folder Structure
            - Config - this folder contains default .ini files that store default Editor and project settings and preferences
            - Content - This folder stores all the assets in the project that are either imported or created directly in the Editor
            - Intermediate - This folder stores the project's working .ini setting and preference files, along with a CachedAssetRegistry.bin file
            - Saved - This folder contains Editor auto save and backup files, a Collection folder for assets organized into collections in the content browser, project Config settings for target platforms, Editor log files, and the project thumbnail .png image file that you see in the Launcher
    b. Asset References and the Reference Viewer
        - Reference Viewer - shows the dependencies for an asset
    c. Gameplay Framework - collection of C++ or Blueprint classes that manages trhe rules of the Game, player input and avatars, cameras, and player HUDs in every project
        - GameMode Class - used to set the rules of the Game and store all the other classes that are needed to define the Game's core functionality
            - DefaultPawn, HUD, PlayerController, Spectator, ReplaySpectator, PlayerState, GameState
        - Controller Classes - controls a pawn in the game
            - PlayerController - manages inputs from the player and directs a pawn in the game by possessing it.
            - PawnClass - takes input from the PlayerController class and uses it to direct the physical representation of the player in the game (Pawn, Character, and Vehicle)
        - HUD Class - used to draw 2D interface content to the player's screen and create in-Game heads-up display

Chapter 3 - Coordinates, Transforms, Units, and Organization
    a. Understanding Cartesian Coordinates
        - Z (Up and Down), Y (Left to Right), X (Front to Back)
    b. Working with Transforms
        - Transformation Tools
            - Move, Scale, Rotate
        - Interactive and Manual Transforms
            - Interactive - using Move, Scale, or Rotate transformation tools
            - Manual - using specific values or numeric setting in the Details Panel for an Actor
        - World and Local Transforms
            - World - use the whole world, understanding that up is up, down i sdown, forward is forward, and so on.
            - Local - references an Actor as the rule setter
    c. Assessing Units and Measurements
        - 1 Unreal Unit UU is equal to 1 real world centimeter, char = 180uu, door = 220uu, etc.
        - Grid Units - Snapping to Grid
    d. Organizing a Scene
        - World Outliner - hierarchical view of actors in a scene
        - Folders - organization tool
        - Grouping - turning a selection of Actors into a single placed Actor
        - Layers
        - Attaching - attaching Actors to each other to create parent-child relationships

Chapter 4 - Working with Static Mesh Actors
    a. Static Mesh Assets - store the pivot point, vertices, edges, and polygons that define the visual look of a model, as well as LODs
    b. Static Mesh Editor - allows you to edit, modify, and set base properties for Static Mesh assets stored in the Content Browser
    c. Viewing UV Layouts
        - UV Channel 0 - UV Channels
        - UV Channel 1 - Lightmap Data - used for storing light and shadow information on the surface of a mesh
    d. Collision Hulls - simple primitive shape that surrounds a mesh and is used to identify collision events
        - Collision Event - occurs when two Actor collision hulls hit, touch, or overlap with each other
        - You can: view and edit collision hulls
        - Convex Decomposition - auto-generate collision hulls for more complicated models
        - Per-Poly Collision - most accurate collision you can have, also the most computationally intensive
    e. Static Mesh Actors - placed instances of a Static Mesh asset in a level
        - Mobility Settings
            - Static - tells the light engine that lightning needs to be precalculated
            - Movable - tells the light engine to calculate lightning during runtime
        - You can: change the mesh reference, replace the material and edit collision responses on a Static Mesh Actor
            - Collision Enabled, Response Flags, Object Type

Chapter 5 - Applying Lighting and Rendering
    a. Learning Light Terminology
        - Direct Lighting - refers top light that falls on the surface of an Actor, without any interference from other Actors
        - Indirect or Bounced Lighting - refers to light that has been reflected off the surface of another Actor in the scene
        - Static Lighting - refers to lighting for objects and lights that do not move
        - Dynamic Lighting - refers to lights and objects that may move at runtime
        - Shadows - created when the engine takes snapshots of the silhouette of a mesh from the light's point of view
    b. Understanding Light Types
        - Point Lights - work much like a real world lightbulb, emitting light equally in all directions from a single point in space
        - Spot Lights - emits light from a single point in a cone shape toward a specific direction
        - Sky Light - captures the distant parts of a level, everything further than SkyDistanceThreshold, and appliesd light to it
        - Direction Light - simulates light that is being emitted from a source that is infinitely far away
    c. Using Light Properties
        - Intensity - brightness of light, in lumens
        - Light Color - color of the light
        - Attenuation Radius - maximum distance the light will reach
        - Cast Shadows - determines whether objects affected by the light cast shadows
        - Inside Cone Angle - sets the angle in degrees of a Spot Light's bright area
        - Outside Cone Angle - sets the angle in degrees of a Spot Light's falloff area
        - Temperature - allows you to set the light based on Kelvin color temperature scale
    d. Building Lighting
        - Lightmass - tool for building lighting (Window -> World Settings -> Lightmass)
        - Build - Build -> Lighting Quality -> Preview || Lighting Quality -> High
        - Swarm Agent - manages communication between the editor and Lightmass. Displays the build progress. Can connect to external computing power for over the network rendering
        - Mobility
            - Static - lights that cannot be changed or moved in any way at runtime
            - Movable - lights case completely dynamic light and shadows, and they can change position, rotation, color, brightness, falloff, radius and more
            - Stationary - lights that cannot move, however their brightness and color can be chaged at runtime

Chapter 6 - Using Materials
    a. Understanding Materials
        - Material/Shader - combination of textures, vectors, and other mathematical calculations that work in tandem to create surface decsriptions and properties for assetst in UE4
    b. Physically Based Rendering - use material parameters to allow assets to form their own lighting and shadow information
    c. Material Input Types
        - Base Color/Albedo - core color decsription of a surface in a material minus all shadow and lighting detail
        - Metalness - used to describe whether a material is metallic
        - Roughness - represents the roughness and the history of the surface of the material being created
        - Normal - normal map textures or three-vector values, decsribe the direction in which light should react with a surface
    d. Creating Textures
        - Powers of 2 - 4096, 2048, 1024, 512, 256, 128, 64, 32, 165, 8, 4, 2
        - Mipping or Mip Mapping - UE4 reduces texture size by continuously halving it as the player gets farther from the asset
        - Texture File Type - .tga, .psd, .tiff, .bmp, .float, .pcx, .png, .jpg, .dds, .
        - Importing Textures
    e. Making a Material
        - Content Browser -> Create Basic Asset/Material
        - Material Editor Panels
            - Viewport Panel - real time preview of the material
            - Details Panel - where you can change overall material properties
            - Graph Panel - visual editing
            - Palette Panel - houses all the special nodes and math functions for creating specific effects within a material
        - Inputs and Outputs
        - Value Nodes - numbers that can create values or colors depending on the number of values used
            - Constant Node - single number or value
            - Constant3Vector Node - vector of three numbers, each representing a RGB value
        - Instances - key to reusing materials multiple times, change node to parameter for flexibility

Chapter 7 - Using Audio System Elements
    a. Introducing Audio Basics
        - Audio Components - Sound Wave, Ambient Sound ACtor, Sound Cue Assets and Sound Cue Editor, and Sound Attentuation
        - Importing Audio Files - .wav drag and drop, and audacityteam.org
    b. Using Sound Actors
        - Ambient Sound Actor Properties
             - Sound - sound wave asset or sound cue asset
             - Is UI Sound - determines whether the sound asset plays when the game is paused
             - Volume Multiplier - sets the overall volume of the sound
             - Pitch Multiplier - sets the overall pitch of the  sound
             - Instance Parameters - allows addition of per-instance parameters for the sound
             - Sound Class Override - optionally assigns a group for the sound asset
        - Setting Attenuation - falloff of the sound as you move further away from it in 3D space
            - Attenuate - enables the use of attenutation via volume
            - Spatialize - enables the source to be positioned in 3D space
            - Distance Algorithm - specifies the type of volume versus distance algorithm
            - Attenuation Shape - specifies the shape of the attentuation volume, usually a sphere
            - Radius - specifies the overall size of the volume
            - Falloff Distance - specifies the distance over which falloff occurs
            - Non-Spatialized Radius - specifies the distance at which spatialization begins
        - Using Modulation Properties
            - Pitch Modulation Min, Pitch Modulation Max, Volume Modulation Min, Volume Modulation Max, High Frequency Gain Multiplier
        - Creating Sound Cues - powerful sound control
            - Graph Panel - flow of audio from left to right
            - Palette Panel - lists various sound nodes that you can use in teh Graph panel and chain together to create complex sounds
            - Play Cue - plays an entire Sound Cue
            - Play Node - plays just audio coming from a selected node
    c.Â Controlling Sounds with Audio Volumes
        - Audio Volumes - used to control and apply various sounds in a scene

Chapter 8 - Creating Landscapes and Foliage
    a. Working with Landscapes
        - Landscape Tools - Manage, Sculpt, and Paint
            - Manage Tab - create and manage existing landscapes, create based on parameters or from an imported height map
            - Height Maps - texture that provides height variation information based on a grayscale. White surfaces indicate landscape height increases, while black indicates height decreases
        - Creating Landscapes
            - Material and Material Layers
            - Landscape Level of Detailing
            - Density and Size of Landscape Tile
            - Fill World - creates a landscape that is the size of the entire game space that is currently available
            - Create - confirms the settings and uses them to create a new landscape
        - Landscape Management
            - Manage - Selecting, Adding, Deleting, Updating Size, Moving
            - Splines - series of connected points that run on top of the landscape
    b. Sculpting Shapes and Volumes
        - Tool Menu
            - Sculpt - sculpts up or down into the landscape mesh
            - Smooth - brushes smoothness or lessens the variation difference between areas being influenced by the scultp tool
            - Flatten - flattens the ladndscape to the height specified when you first click the landscape with the Flatten tool activated
            - Ramp - connects two areas by ramping the landscape between the two with a constant change in grade between points
            - Hydro Erosion and Erosion - simulates general wear of the ground that happens in a world scenario
            - Noise - applies a general noise to the landscape
            - Retopologize - reduces the spacing and difference in variation between surface components to reduce stretching
            - Visibility - hides or unhides selections of surfaces on the landscape mesh
            - Selection - masks selections of the landscape mesh
            - Copy/Paste - selects a section of the landscape to paste similar height settings into another section of the landscape
        - Brush Menu
            - Circle - most basic and default brush
            - Alpha - uses a specific texture as a mask influenced by a grayscale similar to a height map
            - Pattern - uses a repeating pattern
            - Component - affects whole component pieces of the area being sculpted
        - Falloff Menu
            - Smooth - soft blend between strong and weak parts of the brush
            - Linear - direct constant falloff
            - Spherical - weaker influenced falloff toward the center and increases to a stronger influence toward the edge end of the brush
            - Tip - strong influence at the center with a quick falloff to a weaker falloff that slowly dissipates toward the edges
        - Painting - paint material layers onto the landscape mesh
        - Landscape Materials - LandscapeLayerBlend
            - LB_WeightBlend - blends on an additive value of 0 to 1, the more of the layer that is painted on the landscape, the more predominately visible the layer becomes
            - LB_HeightBlend - blends based on the associated height map assigned with the height layer input
            - LB_AlphaBlend
    c. Using Foliage - collection of assets placed on top of and in direct relation to the landscape mesh
        - Paint - painting options of the static meshes
        - Reapply - applies current setttings to all of the currently placed Foliage Static Meshes
        - Select - allows you to select certain groups of selections in the entire world space of Foliage Static Meshes
        - Lassso - allows you to select certain groups of selections
        - Fill - allows you to fill complete selections in the scene with the desire Foliage Static Mesh
        - Placing Foliage - must have Static Meshes added to the Foliage tab

Chapter 9 - World Building
    a. Building Worlds
        - Environmental Narrative - create a narrative that describes what happened to the space you are building
        - Anatomy of a Level
    b. World Building Process
        - Scale and Scope
            - Establishing Scale - 1 unreal unit (uu) is equal to 1  cm. 6ft character will be 182.88 uu
            - Establishing Scope - quality over quantity
        - Shelling and Blocking - block out level's structural assets
        - Prop and Asset Placement
            - Placing Props and Assets
            - Visual Complexity and Framing - create mini compositions that grab attention and help guide them through the world
            - Working with Modular Assets - disguise reuse
            - Combining Actors into a Single Blueprint Class - group and attach Actors together
            - Creating World Beyond - areas that fall beyond the player's reach, the illusion the World is bigger than it is
        - Lighting and Audio Pass
            - Lighting - establishes mood, ties space and asseets together, and affects player's emotional response to environment
                - Remember: shadow colors, Lightmass Importance Volume
            - Audio - huge impact on player perception
        - Playtest and Refine
            - Try to look at level from player's point of view and identify any issues
            - Reflection Capture Actors - capture images of the level from their location and project reflections onto other Actors in the vicinity
            - Fog ACtors - hide imperfections, small level, etc
            - Post Processing Volume Actors - Depth of Field, Motion Blue, Scene Color, Vignette

Chapter 10 - Crafting Effects with Particle Systems
    a. Understanding Particles and Data Types
        - Sprites - common, single camera-facing quad mesh with a texture to define visuals
        - Mesh Data - particle attaches to a single polygonal mesh, great for rockslides or flying debris
        - Anim-trail Data - used with Skeletal Meshes and animation, create trails using sockets from Skeletal Meshes
        - Beam Data - draws a camera facing set of quads that stretch between the recently created particles
        - GPU Sprites - sprites simulated entirely on the graphics processor
        - Ribbon Data - draws quads between each pair of recently placed particles, interpolating bends with smooth curves
    b. Working with Cascade - particle editor
        - Particle System - collection of one or more particle emitters
        - Cascade Panels
            - Toolbar, Viewport, Emitters Panel, Modules Panel, Details Panel, Curves Editor
        - Required Modules
            - Emitter Information
            - Required Module - holds the parameters a Particle Emitter absolutely requires to function
            - Spawn Module - responsible for number of new particles that are created and their frequency or rate of emission
                - Module Properties
                    - Vector Constant - value is same over lifetime of simulation
                    - Vector Constant Curve - property value that changes over time
                    - Vector Uniform - takes in min and max values and returns a uniformly random value between the two
                    - Vector Uniform Curve - time-based result with controlled randomess
            - Using the Curve Editor
                - Toolbar, Channel Visualizers, Property Visualizer, Key
    c. Using Common Modules
        - Required Module - handles most of the bare minimum information required by one emitter
            - Material, Use Local Space, Kill on Deactivated, Kill on Completed, Emitter Duration, Emitter Loops, SubUV
        - Spawn Module - used to determine how many new partricles are created and how often it happens
            - Rate - number of particles to emit per second
            - Rate Scale - used to modulate the number of particles
            - Burst
                - Burst List - list of counts and times to spawn a set number of particles
                - Burst Scale - scales the values determined by the Burst List Property
        - Lifetime Module - requirement, determines how long particles remain in existence
        - Initial Size and Size by Life Modules
            - Initial Size - sets the particle's size at the time they are spawned
            - Size By Life - modulates an individual particle's size over the course of it's lifetime
        - Inital Colr, Scale Color/Life, and Color Over Life Modules
            - Initial Color - sets the particles color at the time they are spawned
            - Scale Color/Life -  modulates color of particle over the lifetime of the particle
            - Color Over Life
        - Initial Veloicity, Inherit Parent Velocity, and Const Acceleration Modules
            - Intial Velocity - starting velocity of every particle
            - Inherint Parent Velocity - emitter speed is applied to particle when it is spawned
            - Const Acceleration - applies a constant amount of acceleration to all particles in the emitter evenly
        - Initial Location and Sphere Modules
            - Initial Location - uses a vector distribuion to pick the starting location of each particle
            - Spheres - distributes starting location of particles throughout a sphere volume
        - Initial Rotation and Rotation Rate Modules
            - Intial Rotation - sets the starting rotation of each particle
            - Rotation Rate - give all particles a unique amount of angular velocity
    d. Setting Up Materials for Particles
        - Particle Color
        - SubUV Textures - used for special effects where distinct frames of an animation are prerendered into a single texture sheet
            - Step 1: Tell the emitter's Required Module that number of columns and rows in the Sub UV texture
            - Step 2: Create a SubImage index in the Particle Emitter and set up a curve, picking which frames to show at which time
            - Step 3: Place a ParticleSubUV or TextureParameterSubUV node in the material graph of the applied material
    e. Triggering Particle Systems
        - Auto Activate - wherever it is place - Actor -> Activation -> Auto Activate Property
        - Activating Particle Systems Through Level Blueprints - pass a reference to an emitter Actor and use it to control the activation state of a Particle System

Chapter 11 - Using Skeletal Mesh Actors
    a. Defining Skeletal Meshes
        - Note - vertices are manipulated by a skeleton-like hierachy of the independent location
        - Skinning or Skinned Mesh - refers to the process of binding vertices to the underlying skeleton
        - Three Components for Animating a Skeletal Mesh
            - Skeletal Mesh - skinned vertices that go with a set of internal bones, defines the appearance of the mesh, including how materials are assigned
            - Skeleton
            - Animation Sequence - record of how a skeleton moves, including the keyframe location, rotation, and scale of each animated bone in the skeleton
            - BONUS - Physic Assets - defines the simplified collision gemoetry attached to the skeleton, if it needs to interact with the physics system
            - BONUS - Animation Blueprints - responsible for the logic necessary to choose which animation sequences to use at which times
    b. Importing Skeletal Meshes
        - Use a 3rd Party Tool e.g. Maya, Autodesk 2DS Max, or SideFX's Houdini
        - Best Practices
            - Triangulate the mesh prior to export
            - Select root of the mesh skeleton and use an option such as Export Selected Only, when exporting
            - Smoothing groups should be enabled
            - Preserver edge orientation should be enabled
            - Tangent and binomials (also known as tangent space) should be disabled
            - Import mesh with no animations attached and the character in a default bind pose
        - FBX Import Options
            - Import As Skeletal - mesh is treated as a Skeletal Mesh
            - Import Mesh - unchecking causes UE4 to ignore the mesh completely
            - Skeleton - if optio blank, a new skeleton is created
            - Import Animations
            - Tranform - correct differences in software packages scene setup
            - Import Materials
            - Convert Scene - causes UE4 to convet the Y+ up axis of most recent packages to the Z+ up axis of Unreal Engine
    c. Learning Persona - editor for working with Skeletal Meshes, skeletons, animation sequences, and animation Blueprints
        - Skeleton Mode
            - Reference Pose Button - stops animations and returns character to reference pose
            - Skeleton Mode Button
            - Skeleton Tree - displays hierarchical outline of bones in the skeleton
            - Persona Viewport - miniature scene view that shows the selected skeleton and Skeletal Mesh
        - Mesh Mode
            - Mesh Mode Button
            - LOD Settings Category
            - Physics Cateogry - apply a Skeletal Mesh's physics asset
            - LOD Visualizer - override displayed LOD, to visualize different LODs on your mesh
            - Viewport Statistics
            - Morph Target Previews
        - Animation Mode
            - Create Asset Button - create new montages, animationm sequences, and other animation type assets
            - Animation Mode Button
            - Details Panel
            - Anim Asset Details
            - Anim Sequence Editor - modify Additive Animation Curves, Notifications, and Tracks in a Timeline keyframe fashion
            - Timeline - modify current playback time and animation 
            - Asset Browsers - quick browser for animation assets
        - Graph Mode - handles logic for bledning different animation states and behaviors
    d. Using Skeletal Mesh Actors
        - Important Animation Category Properties in Static Mesh Actor
            - Animation Mode - use animation Blueprint or a single animation asset
            - Anim to Play - specify a reference from the Content Browser to play a single animation asset
            - Looping - animation will play continuously
            - PLaying - means animtion will play when the game begins instead of waiting to be set manually through Blueprints or some other method
            - Initial Position - determines the starting time of the animation
            - PlayRate - how fast the animation plays back

Chapter 12 - Matinee and Cinematics
    a. Matinee Actors
        - Matinee - toolset and piepeline fro creating in-game cinematics
        - Matinee Actor Properties
    b. Matinee Editor
        - Menu Bar, Toolbar, Curve Editor, Tracks Panel, Details Panel, Time Bar
        - Tracks Panel - Groups and Tracks to keep things organized
        - Play Head - shows where you are in time while editing a sequence and allows you to place keyframes in a track at a specific time
        - Groups - store the Actor or Actors that you want to control and the tracks that you are using
        - Tracks - used to set and store keyframe data over time for specified properties (16 predefined, customizable)
        - Folders - used to organize groups in Matinee
    c. Curve Editor - micromanage interperloation data represented as a spline
        - Interpolation Modes
            - Curve (Red) - control ease-in and ease-out effects
            - Linear (Green) - stratifies the change in values between keyframes evenly over time
            - Constant (Black) - holds the last keyframes values for all the in-between frames until the next keyframe
    d. Working with Other Tracks
        - Sound Track - allows you to play a Sound Wave asset or a Sound Cue
    e. Working with Cameras in Matinees
        - Camera Groups and Actors
        - Director Group - unique group that allows you to work like a film editor 
            - Director Track - switches the current view between Camera groups throughout the sequence
            - Fade - allows you to set fade-ins/fade-outs over the sequence on the active camera
            - Slomo - uses keys to temporarily change the playback speed of the sequence
            - Audio Master - controls the volume and pitch of all the audio tracks in the sequence
            - Color Scale - changes the color tiniting of the rendered frame while the Matinee sequence is playing
        - Working with Matinee Data Assets - stores group, track, folder, and keyframe data and is accessible through the Content Browser

Chapter 13 - Learning to Work with Physics
    a. Using Physics in UE4
        - Key Terminology
            - Physics Body - actor that responds to external forces and collisions, Static Mesh set to simulate physics
            - Engine - NVIDIA PhysX Engine - processes rigid bodies, soft bodies, cloth, destructibles, and particles
            - Rigid Body - solid, non-deformable object, such as a piece of wood or a beach ball
            - Soft Body - deformable object that conforms to the world around it when it collides with something
            - Cloth - a type of soft body
            - Destructible - a rigid body that fractures and crumbles when enough force has been applied
            - Linear - refers to a directional force that changes the position of an Actor in a level
            - Angular - refers to rotational forces that change the orientation of an Actor
            - Mass - refers to the amount of matter in a given body
            - Desnity - amount of mass by volume in a give physics body
            - Damping - refers to how quickly a physics body comes to rest after a force has been applied, dissipation of energy over time
            - Friction - amount of resistance applied to a sliding or rolling body
            - Restitution - amount of bounce a physics body has and how quickly the body comes to rest
            - Force - applied to a mass for a duration
            - Impulse - an instantaneous hit
        - Applying Physics Game Mode to a Level - Settings -> Project Settings -> Game Mode -> GameMode Override to SimplePhysicsGameMode
        - Project and World Physics Settings
            - Entire Project - Settings -> Project Settings
            - Individual Level - World Settings -> Physics
    b. Simulating Physics
        - Physic Properties for a Static Mesh Actor
            - Simulate Physics - physics simulation on and off for the Actor
            - Mass in KG - mass of the body in KG
            - Linear Damping - drag force added to reduce linear movement
            - Angular Damping - drag force added to reduce angular movement
            - Enable Gravity - should the object have the force of gravity applied
            - Contraints - controls which axises teh ACtor can move and rotate on when simulating physics
            - Modes - presets for constraint assignments
            - Start Awake - whether the object should start aware or initially be sleeping
            - Center of Mass Offset - offset for the center of the mass of this object
            - Mass Scale - per instance scaling of mass
            - max Angular Velocity - limits the amount of angular velocity that can be applied
            - Use Async Scene - body is put into asynchronous physics scene
            - Sleep Family - set of values used to consider when to put this body to sleep
            - Position Solver Iteration Count
            - Velocity Solver Iteration Count
    c. Using Physical Materials
        - Creating a Physical Material Asset - Content Browser -> New Folder -> Right Click - Physics -> Physical Material
        - Adding a Physical Material to a Static Mesh Actor - Select Actor -> Level Details Panel: Collision
        - Adding a Physical Material to a Material - Material Editor: Material -> Final Material Node -> Phys Material Override -> Drag Physical Material Asset
    d. Working with Constraints - allow you to control the movement of a physics body by locking movement and rotation on a specific axis
        - Attaching Physics to Actors - attaching relationship is ignored for physics acting on two bodies
        - Physics Constraint Actors - link Physics Actors to any other Actor
            - Constraint Actor - create a joint, or hinge, between two physical bodies
                - Free - no constraint at all
                - Lock - no movement at all
                - Limited - set a range of movement
    e. Using Force Actors
        - Physics Thruster Actor - applies a force in specified direction to a Physics Actor
        - Radial Force Actors - applies force in all directions from a single point of influence

Chapter 14 - Introducing Blueprint Visual Scripting System
    a. Visual Scripting Basics
        - Blueprint - visual scripting environment
            - Compiling
                - Compiler - software used to compile instructions written in a programming language
                - Compiling - turning instructions into machine language that can be executed by the CPU
                - Bytecode - compiled source code that is processed by a virtual machine instead of hardware
                - Virtual Machine - software that translates byte code into instructions the hardware can understand and process
    b. Understanding the Blueprint Editor
        - Level Blueprint - used to manage global events for a level, there is only one level blueprint for each level, and it is automatically saved when the level is saved
        - Blueprint Class - class derived from an existing class that has been made in C++ or from another Blueprint class. It is used to code functionality for Actors placed in a level
        - Data-Only Blueprint - only stores the modified properties of an inherited Blueprint
        - Blueprint Interface - Blueprint Interfaces are used to store a collection of user defined functions that can be assigned to other Blueprints. BPIs allow other Blueprints to share and pass data among each other
        - Blueprint Macros - these are self-contained node graphs of a commonly used sequence of nodes that can be reused throughout other blueprints. Blueprint Macros are stored in a Blueprint Macro Library
        - Blueprint Editopr Interface
            - Toolbar, Blueprint Panel, Details Panel, Event Grap
            - Blueprint Editor Toolbar
                - Compile - compiles a Blueprint
                - Search - opens a find result panel with a search box for locating nodes in a Blueprint
                - Class Settings - shows the options for the Blueprint in the Details panel
                - Class Defaults - displays the properties for the Blueprint in the Details panel
                - Play - previews the level
            - Blueprint Panel - keeps track of all the node graphs, functions, marcos, and variables that your Blueprint uses
            - Event Graph - where you do most of your work when using the Blueprint Editor.
            - Blueprint Context Menu - context sensitive by default, showing you the actions that are relefvant to what you currently have selected
            - Nodes, Wires, Execs, and Pins
                - Nodes - visual representation of events, functions, variables, and are color coded to represent their use
                    - Red Node - event node, used to initiate the execution of a sequence of node 
                    - Blue Node - functions to perform specific operations
                    - Multicolored Oval Node - variables
                    - In and Out exeuction pins (execs), are the white facing triangles that denote sequence flow
                    - Data Pins are color coded based on the type of data they need
                    - Wires - connect nodes  
    c. Fundamental Concepts in Scripting
        - Events
            - BeginOverlap - fires when the collision hulls of two Actors overlap
            - EndOverlap - fires when the colision hulls of two Actors stop overlapping
            - Hit - fires when the collision hulls of two Actors touch but don't overlap
            - BeginPlay - fires every time a level is loaded into memory and played
            - EndPlay - fires when the level is over
            - Destroyed - fires when an Actor has been removed from memory
            - Tick - fires with every tick of the CPU
            - Custom - acts as the user has defined it to work, based on specific needs
        - Functions - a piece of code that performs specific operations, takes in data stored in variables, processes the information, and in most cases returns a result 
        - Variables - store different types of data]
            - Boolean = Red - 0 or 1
            - Integer = Cyan - whole round number
            - Float = Green - decimal
            - String = Magenta - text
            - Vector = Gold - three floats X, Y, and Z
            - Rotator = Purple - vector that stores three float X is roll, Y is pitch, and Z is yaw
            - Transform = Orange - a struct that stores a vector for location, rotator for orientation, and a vector for scale
            - Object = Blue - refers to an Actor in the level and stores all of its properties in memory
        - Operators and Conditionals
            - Operators - mathematical operations such as addition, subtraction, multiplication, and division
            - Conditionals - allow you to check or compare the state of a variable and then respond accordingly
        - Script Organization and Commenting
            - Node Comments - allow you to make notes on any node
            - Comment Box - allow you to wrap a selection of nodes inside a box and add a text comment
            - Reroute Nodes - helps control the placement of a wire

Chapter 15 - Working with Level Blueprints
    a. Actor Collision Examples
        - Order to Setup OnActorBeginOverlap
            - Add Box Trigger Actor
            - Select Simulation Generates Hit Events or Generate Overlap Events to broadcast Collision Events to Level Blueprint
            - Select Actor in Level -> Blueprint Event Graph: Context Menu -> Context Sensitive -> Add Event for My Trigger Box -> Collision -> Add OnActorBeginOverlap Event
            - OnActorBeginOverlap Event Node: Other Actor Pin -> Get Display Name -> Print String
        - Order to Assign Actor to ACtor Reference Variable=
            - Select Actor in Level -> Blueprint Event Graph: Context Menu -> Add Actor as Reference Variable
        - Order to Set Property of an Actor or Sub Component
            - Get Actor Reference Using Above
            - Optional: Get Sub Component from Actor
            - Get Function that Targets Actor/Subcomponent e.g. SetActorLocation or Set Static Mesh
            - OnActorBeginOverlap exec pin to SetActorLocation w/ Target Input the Actor or Component Reference Variable Object
        - Order to Activate Property e.g. Start Emittor or Play Sound
            - Get Actor Reference e.g. Emitter or Ambient Sound Actor
            - Get Function that Targets Activiation of Specific Actors e.g. Activate, Deactivate, IsActive, SetActivate, ToggleActive
            - OnActorBeginOverlap exec pin to Activate w/ Target Input the Actor Reference Variable Object
        - Order to Play Sound
            - Add Play Sound at Location Function
            - OnActorBeginOverlap exec pin to Play Sound at Location
            - Play Sound At Location: Sound - Sound Cue Asset

Chapter 16 - Working with Blueprint Classes
a. Using Blueprint Classes - script new actors that can be reused in any level
    b. The Blueprint Editor Interface
        - Components Panel - lists all the components in the Blueprint and is used to manage them
        - Viewport Panel - displays the components in the Blueprint and is used to set up the spatial relationships of the components in the Actor
        - Construction Script - unique function that runs when an instance of the Blueprint (an Actor) is placed in a level. It is a node graph that, when executed, modifies each instance independently of the original blueprint KEY*
        - Toolbar - Saves, Find in Content Browser, Simulation
    c. Working with Components
        - What - sub object element of a blue print
        - Adding Components
            - +Add Components or click+drag
        - Viewport Panel - use transform gizmos to adjust the location, rotation, and scale of each of the components in the blueprint
        - Blueprint Scripting with Components
            - Note: while working inside the Actor blueprint, use self when referring to the Actor
            - Add a component to the Blueprint class Event Graph as a component reference variable by click+drag the component into the Event Graph
    d. Working with the Timeline
        - Timeline Node - allows you to create spline curve data that can be used in a Blueprint to change values over time e.g. animate the position of an Actor and/or its components
        - Add a Timeline Node - right+click, Add Timeline
        - Timeline Tracks and Curves
            - Types - Float, Vector, Color, and Event
            - Add Track - click type you want
            - Modify - move key
    e. Scripting a Pulsating Light - pg. 301

Chapter 17 - Using Editable Variables and the Construction Script
    a. Setting Up
    b. Making Editable Variables
        - Editable - can be modified outside of the blueprint, should provide tooltip and category
        - Order - Actor Blueprint -> Variables+ -> Check Editable Variable
    c. Using the Construction Script
        - Update - every time an Actor's propertiers or transforms change in the Blueprint Editor, or when you compile the Blueprint, changes are seen while working in editor
        - Limitations - cannot spawn new Actors
        - Limiting Editable Variables - slider range and value range properties

Chapter 18 - Making Key Input Events and Spawning Actors
    a. Why Spawning is Important
    b. Creating a Blueprint Class to Spawn
        - Order - create a Blueprint class to spawn, use construction script to set dynamic values
        - Sequence Node - splits the event signal into as many signals as you need
        - Expose on Spawn Variable Property - exposes the variable to whichever Blueprint is spawning the new actor
    c. Setting up the Spawner Blueprint
         - Collider - OnComponentBeginOverlap - Enable Input
         - Spawn Functions - Actor, Emitter, Sound, etc.
    d. Spawning an Actor from a Class
        - Keyboard Input Event - KeySpawner_BP Blueprint - E - Spawn Actor from Class fn() - Pick Blueprint - Provide Location Values


Chapter 19 - Making an Action Encounter
    a. Project Game Modes
    b. Knowing Characters' Abilities
    c. Using Blueprint Classes
    d. Actor and Component Tags

Chapter 20 - Creating an Arcade Shooter: Input Systems and Pawns
    a. Identifying Requirments with a Design Summary
    b. Creating a Game Project
    c. Creating a Custom Game Mode
    d. Creating a Custom Pawn and Player Controller
    e. Controlling a Pawn's Movement
    f. Setting Up a Fixed Camera

Chapter 21 - Creating an Arcade Shooter: Obstacles and Pickups
    a. Creating an Arcade Shooter: Obstacles and Pickups
    b. Making Your Obstacle Move
    c. Damaging the Pawn
    d. Restarting the Game on Death
    e. Creating a Health Pickup
    f. Creating an Actor Spawner
    g. Cleaning Up Old Obstacles

Chapter 22 - Working with UMG
    a. Creating a Widget Blueprint
    b. Navigating the UMG Interface
    c. Creating a Start Menu
    d. Sample Menu System

Chapter 23 - Making an Executable
    a. Cooking Content
    b. Packaging A Project for Windows
    c. Resources for Android and iOS Packaging
    d. Accessing Advanced Packaging Settings

Chapter 24 - Working with Mobile
    a. Developing for Mobile Devices
    b. Using Touch
    c. Using a Device's Motion Data